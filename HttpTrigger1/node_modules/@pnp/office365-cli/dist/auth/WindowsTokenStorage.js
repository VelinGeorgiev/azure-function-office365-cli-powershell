"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const os = require("os");
const path = require("path");
const buffer_1 = require("buffer");
class WindowsTokenStorage {
    constructor() {
        this.credsExePath = path.join(__dirname, '../../bin/windows/creds.exe');
        this.prefix = 'Office365Cli:target=';
        this.prefixShort = 'Office365Cli';
        this.MAX_CREDENTIAL_BYTES = 2048;
        this.propertyRegex = /^([^:]+):\s(.*)$/;
    }
    get() {
        return new Promise((resolve, reject) => {
            const args = [
                '-s',
                '-g',
                '-t', `${this.prefix}${this.prefixShort}*`
            ];
            childProcess.execFile(this.credsExePath, args, (err, stdout, stderr) => {
                if (err) {
                    reject(err.message);
                    return;
                }
                const lines = stdout.split(os.EOL);
                const creds = [];
                let cred = { name: '', value: '' };
                lines.forEach(l => {
                    // empty line is a separator, so reset object
                    if (l === '') {
                        cred = { name: '', value: '' };
                    }
                    const m = this.propertyRegex.exec(l);
                    if (!m) {
                        return;
                    }
                    switch (m[1]) {
                        case 'Target Name':
                            cred.name = m[2];
                            break;
                        case 'Credential':
                            cred.value = m[2];
                            break;
                    }
                    if (cred.name.length > 0 && cred.value.length > 0) {
                        creds.push(cred);
                    }
                });
                if (creds.length === 0) {
                    reject('Credential not found');
                    return;
                }
                let rawPassword = '';
                if (creds.length === 1 && !this.isPartialEntry(creds[0].name)) {
                    rawPassword = creds[0].value;
                }
                else {
                    const chunks = [];
                    let numChunks = 0;
                    creds.forEach(c => {
                        const chunkInfo = this.getChunkInfo(c.name);
                        if (chunkInfo.length !== 2) {
                            return;
                        }
                        if (chunkInfo[0] === 1) {
                            numChunks = chunkInfo[1];
                        }
                        chunks[chunkInfo[0]] = c.value;
                    });
                    if (chunks.length - 1 !== numChunks) {
                        reject(`Couldn't load all credential chunks. Expected ${numChunks}, found ${chunks.length - 1}`);
                        return;
                    }
                    for (let i = 1; i < chunks.length; i++) {
                        if (!chunks[i]) {
                            reject(`Missing chunk ${i}/${numChunks}`);
                            return;
                        }
                    }
                    rawPassword = chunks.join('');
                }
                resolve(buffer_1.Buffer.from(rawPassword, 'hex').toString('utf8'));
            });
        });
    }
    ;
    set(connectionInfo) {
        return new Promise((resolve, reject) => {
            // because the new token might be longer/shorter than the previous one
            // we first need to clear the previous entry to avoid issues
            this
                .remove()
                .then(() => {
                const entries = [];
                if (connectionInfo.length <= this.MAX_CREDENTIAL_BYTES) {
                    entries.push({ name: this.prefix + this.prefixShort, value: connectionInfo });
                }
                else {
                    const numBytes = connectionInfo.length;
                    let numBlocks = Math.ceil(numBytes / this.MAX_CREDENTIAL_BYTES);
                    for (let i = 0; i < numBlocks; i++) {
                        entries.push({
                            name: `${this.prefix}${this.prefixShort}--${i + 1}-${numBlocks}`,
                            value: connectionInfo.substr(i * this.MAX_CREDENTIAL_BYTES, this.MAX_CREDENTIAL_BYTES)
                        });
                    }
                }
                let i = 0;
                entries.forEach(e => {
                    const args = [
                        '-a',
                        '-t', e.name,
                        '-p', buffer_1.Buffer.from(e.value, 'utf8').toString('hex')
                    ];
                    childProcess.execFile(this.credsExePath, args, (err, stdout, stderr) => {
                        if (err) {
                            reject('Could not add password to credential store: ' + err.message);
                        }
                        else {
                            ++i;
                            if (i === entries.length) {
                                resolve();
                            }
                        }
                    });
                });
            }, (error) => {
                reject(error);
            });
        });
    }
    ;
    remove() {
        return new Promise((resolve, reject) => {
            const args = [
                '-d',
                '-g',
                '-t', `${this.prefix}${this.prefixShort}*`
            ];
            childProcess.execFile(this.credsExePath, args, (err, stdout, stderr) => {
                if (err) {
                    reject('Could not remove password from credential store: ' + err.message);
                }
                else {
                    resolve();
                }
            });
        });
    }
    ;
    isPartialEntry(entryName) {
        return /--\d+-\d+$/.test(entryName);
    }
    getChunkInfo(entryName) {
        const m = /--(\d+)-(\d+)$/.exec(entryName);
        if (m) {
            return [parseInt(m[1]), parseInt(m[2])];
        }
        else {
            return [];
        }
    }
}
exports.WindowsTokenStorage = WindowsTokenStorage;
//# sourceMappingURL=WindowsTokenStorage.js.map