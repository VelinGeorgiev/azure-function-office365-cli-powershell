"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const KeychainTokenStorage_1 = require("./auth/KeychainTokenStorage");
const WindowsTokenStorage_1 = require("./auth/WindowsTokenStorage");
const FileTokenStorage_1 = require("./auth/FileTokenStorage");
const adal_node_1 = require("adal-node");
const Command_1 = require("./Command");
const config_1 = require("./config");
const node_forge_1 = require("node-forge");
const request_1 = require("./request");
class Service {
    constructor() {
        this.connected = false;
        this.authType = AuthType.DeviceCode;
        this.accessTokens = {};
    }
    logout() {
        this.connected = false;
        this.accessTokens = {};
        this.refreshToken = undefined;
        this.authType = AuthType.DeviceCode;
        this.userName = undefined;
        this.password = undefined;
        this.certificate = undefined;
        this.thumbprint = undefined;
        this.spoUrl = undefined;
        this.tenantId = undefined;
    }
}
exports.Service = Service;
var AuthType;
(function (AuthType) {
    AuthType[AuthType["DeviceCode"] = 0] = "DeviceCode";
    AuthType[AuthType["Password"] = 1] = "Password";
    AuthType[AuthType["Certificate"] = 2] = "Certificate";
    AuthType[AuthType["Identity"] = 3] = "Identity";
})(AuthType = exports.AuthType || (exports.AuthType = {}));
class Auth {
    constructor() {
        this.appId = config_1.default.cliAadAppId;
        this._service = new Service();
        this.authCtx = new adal_node_1.AuthenticationContext(`https://login.microsoftonline.com/${config_1.default.tenant}`);
    }
    get service() {
        return this._service;
    }
    get defaultResource() {
        return 'https://graph.microsoft.com';
    }
    restoreAuth() {
        return new Promise((resolve, reject) => {
            this
                .getServiceConnectionInfo()
                .then((service) => {
                this._service = Object.assign(this._service, service);
                resolve();
            }, (error) => {
                resolve();
            });
        });
    }
    ensureAccessToken(resource, stdout, debug = false, fetchNew = false) {
        adal_node_1.Logging.setLoggingOptions({
            level: debug ? 3 : 0,
            log: (level, message, error) => {
                stdout.log(message);
            }
        });
        return new Promise((resolve, reject) => {
            const now = new Date();
            const accessToken = this.service.accessTokens[resource];
            const expiresOn = accessToken ? new Date(accessToken.expiresOn) : new Date(0);
            if (!fetchNew && accessToken && expiresOn > now) {
                if (debug) {
                    stdout.log(`Existing access token ${accessToken.value} still valid. Returning...`);
                }
                resolve(accessToken.value);
                return;
            }
            else {
                if (debug) {
                    if (!accessToken) {
                        stdout.log(`No token found for resource ${resource}`);
                    }
                    else {
                        stdout.log(`Access token expired. Token: ${accessToken.value}, ExpiresAt: ${accessToken.expiresOn}`);
                    }
                }
            }
            let getTokenPromise = this.ensureAccessTokenWithDeviceCode.bind(this);
            if (this.service.refreshToken) {
                getTokenPromise = this.ensureAccessTokenWithRefreshToken.bind(this);
            }
            else {
                switch (this.service.authType) {
                    case AuthType.DeviceCode:
                        getTokenPromise = this.ensureAccessTokenWithDeviceCode.bind(this);
                        break;
                    case AuthType.Password:
                        getTokenPromise = this.ensureAccessTokenWithPassword.bind(this);
                        break;
                    case AuthType.Certificate:
                        getTokenPromise = this.ensureAccessTokenWithCertificate.bind(this);
                        break;
                    case AuthType.Identity:
                        getTokenPromise = this.ensureAccessTokenWithIdentity.bind(this);
                        break;
                }
            }
            let error = undefined;
            getTokenPromise(resource, stdout, debug)
                .then((tokenResponse) => {
                this.service.accessTokens[resource] = {
                    expiresOn: tokenResponse.expiresOn,
                    value: tokenResponse.accessToken
                };
                this.service.refreshToken = tokenResponse.refreshToken;
                this.service.connected = true;
                return this.storeConnectionInfo();
            }, (_error) => {
                error = _error;
                // return rejected promise to prevent resolving the parent promise
                // with access token when there is none
                return Promise.reject(_error);
            })
                .then(() => {
                resolve(this.service.accessTokens[resource].value);
            }, (_error) => {
                // _error could happen due to an issue with persisting the access
                // token which shouldn't fail the overall token retrieval process
                if (debug) {
                    stdout.log(new Command_1.CommandError(_error));
                }
                // was there an issue earlier in the process
                if (error) {
                    reject(error);
                }
                else {
                    // resolve with the retrieved token despite the issue with
                    // persisting the token
                    resolve(this.service.accessTokens[resource].value);
                }
            });
        });
    }
    ensureAccessTokenWithRefreshToken(resource, stdout, debug) {
        return new Promise((resolve, reject) => {
            if (debug) {
                stdout.log(`Retrieving new access token using existing refresh token ${this.service.refreshToken}`);
            }
            this.authCtx.acquireTokenWithRefreshToken(this.service.refreshToken, this.appId, resource, (error, response) => {
                if (debug) {
                    stdout.log('Response:');
                    stdout.log(response);
                    stdout.log('');
                }
                if (error) {
                    reject((response && response.error_description) || error.message);
                    return;
                }
                resolve(response);
            });
        });
    }
    ensureAccessTokenWithDeviceCode(resource, stdout, debug) {
        if (debug) {
            stdout.log(`Starting Auth.ensureAccessTokenWithDeviceCode. resource: ${resource}, debug: ${debug}`);
        }
        return new Promise((resolve, reject) => {
            if (debug) {
                stdout.log('No existing refresh token. Starting new device code flow...');
            }
            this.authCtx.acquireUserCode(resource, this.appId, 'en-us', (error, response) => {
                if (debug) {
                    stdout.log('Response:');
                    stdout.log(response);
                    stdout.log('');
                }
                if (error) {
                    reject((response && response.error_description) || error.message);
                    return;
                }
                stdout.log(response.message);
                this.userCodeInfo = response;
                this.authCtx.acquireTokenWithDeviceCode(resource, this.appId, response, (error, response) => {
                    if (debug) {
                        stdout.log('Response:');
                        stdout.log(response);
                        stdout.log('');
                    }
                    if (error) {
                        reject((response && response.error_description) || error.message || error.error_description);
                        return;
                    }
                    this.userCodeInfo = undefined;
                    resolve(response);
                });
            });
        });
    }
    ensureAccessTokenWithPassword(resource, stdout, debug) {
        return new Promise((resolve, reject) => {
            if (debug) {
                stdout.log(`Retrieving new access token using credentials...`);
            }
            this.authCtx.acquireTokenWithUsernamePassword(resource, this.service.userName, this.service.password, this.appId, (error, response) => {
                if (debug) {
                    stdout.log('Response:');
                    stdout.log(response);
                    stdout.log('');
                }
                if (error) {
                    reject((response && response.error_description) || error.message);
                    return;
                }
                resolve(response);
            });
        });
    }
    ensureAccessTokenWithCertificate(resource, stdout, debug) {
        return new Promise((resolve, reject) => {
            if (debug) {
                stdout.log(`Retrieving new access token using certificate (thumbprint ${this.service.thumbprint})...`);
            }
            let cert = '';
            if (this.service.password === undefined) {
                var buf = Buffer.from(this.service.certificate, 'base64');
                cert = buf.toString('utf8');
            }
            else {
                var buf = Buffer.from(this.service.certificate, 'base64');
                let p12Asn1 = node_forge_1.asn1.fromDer(buf.toString('binary'), false);
                let p12Parsed = node_forge_1.pkcs12.pkcs12FromAsn1(p12Asn1, false, this.service.password);
                var keyBags = p12Parsed.getBags({ bagType: node_forge_1.pki.oids.pkcs8ShroudedKeyBag });
                var pkcs8ShroudedKeyBag = keyBags[node_forge_1.pki.oids.pkcs8ShroudedKeyBag][0];
                if (debug) {
                    // check if there is something in the keyBag as well as
                    // the pkcs8ShroudedKeyBag. This will give us more information
                    // whether there is a cert that can potentially store keys in the keyBag.
                    // I could not find a way to add something to the keyBag with all 
                    // my attempts, but lets keep it here for troubleshooting purposes.
                    stdout.log(`pkcs8ShroudedKeyBagkeyBags length is ${[node_forge_1.pki.oids.pkcs8ShroudedKeyBag].length}`);
                    keyBags = p12Parsed.getBags({ bagType: node_forge_1.pki.oids.keyBag });
                    stdout.log(`keyBag length is ${keyBags[node_forge_1.pki.oids.keyBag].length}`);
                }
                // convert a Forge private key to an ASN.1 RSAPrivateKey
                const rsaPrivateKey = node_forge_1.pki.privateKeyToAsn1(pkcs8ShroudedKeyBag.key);
                // wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo
                const privateKeyInfo = node_forge_1.pki.wrapRsaPrivateKey(rsaPrivateKey);
                // convert a PKCS#8 ASN.1 PrivateKeyInfo to PEM
                cert = node_forge_1.pki.privateKeyInfoToPem(privateKeyInfo);
            }
            this.authCtx.acquireTokenWithClientCertificate(resource, this.appId, cert, this.service.thumbprint, (error, response) => {
                if (debug) {
                    stdout.log('Response:');
                    stdout.log(response);
                    stdout.log('');
                }
                if (error) {
                    reject((response && response.error_description) || error.message);
                    return;
                }
                resolve(response);
            });
        });
    }
    ensureAccessTokenWithIdentity(resource, stdout, debug) {
        return new Promise((resolve, reject) => {
            const userName = this.service.userName;
            if (debug) {
                stdout.log('Wil try to retrieve access token using identity...');
            }
            const requestOptions = {
                url: '',
                headers: {
                    accept: 'application/json',
                    Metadata: true,
                    'x-anonymous': true
                },
                json: true
            };
            if (process.env.IDENTITY_HEADER && process.env.IDENTITY_ENDPOINT) {
                // it is Azure Function or Azure Web App
                requestOptions.url = `${process.env.IDENTITY_ENDPOINT}?resource=${encodeURIComponent(resource)}&api-version=2019-08-01`;
                requestOptions.headers['X-IDENTITY-HEADER'] = process.env.IDENTITY_HEADER;
                if (debug) {
                    stdout.log('IDENTITY_ENDPOINT and IDENTITY_HEADER env variables found it is Azure Function or WebApp...');
                }
            }
            else if (process.env.MSI_ENDPOINT && process.env.MSI_SECRET) {
                // it is Azure Function or Azure Web App, but using the old names of the env variables
                requestOptions.url = `${process.env.MSI_ENDPOINT}?resource=${encodeURIComponent(resource)}&api-version=2019-08-01`;
                requestOptions.headers['X-IDENTITY-HEADER'] = process.env.MSI_SECRET;
                if (debug) {
                    stdout.log('MSI_ENDPOINT and MSI_SECRET env variables found it is Azure Function or WebApp...');
                }
            }
            else {
                // it is not Azure Function so lets attempt to get Managed Identity token by using the Azure Virtual Machine api
                requestOptions.url = `http://169.254.169.254/metadata/identity/oauth2/token?resource=${encodeURIComponent(resource)}&api-version=2018-02-01`;
            }
            if (userName) {
                // if name present then the identity is user-assigned managed identity
                // the name option in this case is either client_id or principal_id (object_id) 
                // of the managed identity service principal
                requestOptions.url += `&client_id=${encodeURIComponent(userName)}`;
                if (debug) {
                    stdout.log('Wil try to get token using client_id param...');
                }
            }
            request_1.default
                .get(requestOptions)
                .then((res) => {
                resolve({ accessToken: res.access_token, expiresOn: parseInt(res.expires_on) * 1000 });
                return;
            })
                .catch((e) => {
                if (!userName) {
                    reject(e);
                    return;
                }
                // since the userName option can be either client_id or principal_id (object_id) 
                // and the first attempt was using client_id
                // now lets see if the api returned 'not found' response and
                // try to get token using principal_id (object_id)
                let isNotFoundResponse = false;
                if (e.error && e.error.Message) {
                    // check if it is Azure Function api 'not found' response
                    isNotFoundResponse = (e.error.Message.indexOf("No Managed Identity found") !== -1);
                }
                else if (e.error && e.error.error_description) {
                    // check if it is Azure VM api 'not found' response
                    isNotFoundResponse = (e.error.error_description === "Identity not found");
                }
                if (!isNotFoundResponse) {
                    // it is not a 'not found' response then exit with error
                    reject(e);
                    return;
                }
                if (debug) {
                    stdout.log('Wil try to get token using principal_id (also known as object_id) param ...');
                }
                requestOptions.url = requestOptions.url.replace('&client_id=', '&principal_id=');
                requestOptions.headers['x-anonymous'] = true;
                request_1.default
                    .get(requestOptions)
                    .then((res) => {
                    resolve({ accessToken: res.access_token, expiresOn: parseInt(res.expires_on) * 1000 });
                })
                    .catch((err) => {
                    // will give up and not try any further with the 'msi_res_id' (resource id) querty string param
                    // since it does not work with the Azure Functions api, but just with the Azure VM api
                    if (err.error.code === 'EACCES') {
                        // the CLI does not know if managed identity is actually assigned when EACCES code thrown
                        // so show meaningfull message since the raw error response could be missleading 
                        reject('Error while logging with Managed Identity. Please check if a Managed Identity is assigned to the current Azure resource.');
                    }
                    else {
                        reject(err);
                    }
                });
            });
        });
    }
    cancel() {
        if (this.userCodeInfo) {
            this.authCtx.cancelRequestToGetTokenWithDeviceCode(this.userCodeInfo, (error, response) => { });
        }
    }
    static getResourceFromUrl(url) {
        let resource = url;
        const pos = resource.indexOf('/', 8);
        if (pos > -1) {
            resource = resource.substr(0, pos);
        }
        return resource;
    }
    getServiceConnectionInfo() {
        return new Promise((resolve, reject) => {
            const tokenStorage = this.getTokenStorage();
            tokenStorage
                .get()
                .then((json) => {
                try {
                    resolve(JSON.parse(json));
                }
                catch (err) {
                    reject(err);
                }
            }, (error) => {
                reject(error);
            });
        });
    }
    storeConnectionInfo() {
        const tokenStorage = this.getTokenStorage();
        return tokenStorage.set(JSON.stringify(this.service));
    }
    clearConnectionInfo() {
        const tokenStorage = this.getTokenStorage();
        return tokenStorage.remove();
    }
    getTokenStorage() {
        const platform = os.platform();
        let tokenStorage;
        switch (platform) {
            case 'darwin':
                tokenStorage = new KeychainTokenStorage_1.KeychainTokenStorage();
                break;
            case 'win32':
                tokenStorage = new WindowsTokenStorage_1.WindowsTokenStorage();
                break;
            default:
                tokenStorage = new FileTokenStorage_1.FileTokenStorage();
                break;
        }
        return tokenStorage;
    }
}
exports.Auth = Auth;
exports.default = new Auth();
//# sourceMappingURL=Auth.js.map