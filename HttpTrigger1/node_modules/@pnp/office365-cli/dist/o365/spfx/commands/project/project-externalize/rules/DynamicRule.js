"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BasicDependencyRule_1 = require("./BasicDependencyRule");
const fs = require("fs");
const request_1 = require("../../../../../../request");
class DynamicRule extends BasicDependencyRule_1.BasicDependencyRule {
    constructor() {
        super(...arguments);
        this.restrictedModules = ['react', 'react-dom', '@pnp/sp-clientsvc', '@pnp/sp-taxonomy'];
        this.restrictedNamespaces = ['@types/', '@microsoft/'];
    }
    visit(project) {
        return new Promise((resolve, reject) => {
            if (!project.packageJson) {
                return resolve({ entries: [], suggestions: [] });
            }
            const validPackageNames = Object.getOwnPropertyNames(project.packageJson.dependencies)
                .filter(x => this.restrictedNamespaces.map(y => x.indexOf(y) === -1).reduce((y, z) => y && z))
                .filter(x => this.restrictedModules.indexOf(x) === -1);
            Promise
                .all(validPackageNames.map((x) => this.getExternalEntryForPackage(x, project)))
                .then((res) => {
                resolve({
                    entries: res
                        .filter(x => x !== undefined)
                        .map(x => x),
                    suggestions: []
                });
            });
        });
    }
    getExternalEntryForPackage(packageName, project) {
        return new Promise((resolve, reject) => {
            const version = project.packageJson && project.packageJson.dependencies[packageName];
            const filePath = this.cleanFilePath(this.getFilePath(packageName));
            if (!version || !filePath) {
                return resolve(undefined);
            }
            let url = this.getFileUrl(packageName, version, filePath);
            let minUrl = url;
            this
                .testUrl(url)
                .then(() => {
                if (!url.endsWith('.min.js')) {
                    minUrl = url.replace('.js', '.min.js');
                    return this.testUrl(minUrl);
                }
                else {
                    return Promise.resolve();
                }
            })
                .then(() => {
                url = minUrl;
                return this.getModuleType(url);
            })
                .then((moduleType) => {
                resolve({
                    key: packageName,
                    path: url,
                    globalName: moduleType === 'script' ? packageName : undefined,
                });
            }, () => {
                return resolve(undefined);
            });
        });
    }
    getModuleType(url) {
        return new Promise((resolve, reject) => {
            request_1.default
                .post({
                url: 'https://scriptcheck-weu-fn.azurewebsites.net/api/script-check',
                headers: { 'content-type': 'application/json', accept: 'application/json', 'x-anonymous': 'true' },
                body: { url: url },
                json: true
            })
                .then((res) => {
                resolve(res.scriptType);
            }, () => {
                resolve('module');
            });
        });
    }
    getFileUrl(packageName, version, filePath) {
        return `https://unpkg.com/${packageName}@${version}/${filePath}`;
    }
    testUrl(url) {
        return request_1.default.head({ url: url, headers: { 'x-anonymous': 'true' } });
    }
    getFilePath(packageName) {
        let result = undefined;
        const packageJsonFilePath = `node_modules/${packageName}/package.json`;
        try {
            const packageJson = JSON.parse(fs.readFileSync(packageJsonFilePath, 'utf8'));
            if (packageJson.module) {
                result = packageJson.module;
            }
            else if (packageJson.main) {
                result = packageJson.main;
            }
        }
        catch (_a) {
            // file doesn't exist, giving up
        }
        return result;
    }
    cleanFilePath(filePath) {
        if (filePath) {
            return filePath.replace('./', '');
        }
        else {
            return undefined;
        }
    }
}
exports.DynamicRule = DynamicRule;
//# sourceMappingURL=DynamicRule.js.map