"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = require("../../commands");
const Command_1 = require("../../../../Command");
const path = require("path");
const fs = require("fs");
const os = require("os");
const FN017001_MISC_npm_dedupe_1 = require("./project-upgrade/rules/FN017001_MISC_npm_dedupe");
const base_project_command_1 = require("./base-project-command");
const vorpal = require('../../../../vorpal-init');
class SpfxProjectUpgradeCommand extends base_project_command_1.BaseProjectCommand {
    constructor() {
        super();
        this.toVersion = '';
        this.packageManager = 'npm';
        this.shell = 'bash';
        this.allFindings = [];
        this.supportedVersions = [
            '1.0.0',
            '1.0.1',
            '1.0.2',
            '1.1.0',
            '1.1.1',
            '1.1.3',
            '1.2.0',
            '1.3.0',
            '1.3.1',
            '1.3.2',
            '1.3.4',
            '1.4.0',
            '1.4.1',
            '1.5.0',
            '1.5.1',
            '1.6.0',
            '1.7.0',
            '1.7.1',
            '1.8.0',
            '1.8.1',
            '1.8.2',
            '1.9.1',
            '1.10.0'
        ];
    }
    get name() {
        return commands_1.default.PROJECT_UPGRADE;
    }
    get description() {
        return 'Upgrades SharePoint Framework project to the specified version';
    }
    getTelemetryProperties(args) {
        const telemetryProps = super.getTelemetryProperties(args);
        telemetryProps.toVersion = args.options.toVersion || this.supportedVersions[this.supportedVersions.length - 1];
        telemetryProps.packageManager = args.options.packageManager || 'npm';
        telemetryProps.shell = args.options.shell || 'bash';
        telemetryProps.outputFile = typeof args.options.outputFile !== 'undefined';
        return telemetryProps;
    }
    action() {
        const cmd = this;
        return function (args, cb) {
            args = cmd.processArgs(args);
            cmd.initAction(args, this);
            cmd.commandAction(this, args, cb);
        };
    }
    commandAction(cmd, args, cb) {
        this.projectRootPath = this.getProjectRoot(process.cwd());
        if (this.projectRootPath === null) {
            cb(new Command_1.CommandError(`Couldn't find project root folder`, SpfxProjectUpgradeCommand.ERROR_NO_PROJECT_ROOT_FOLDER));
            return;
        }
        this.toVersion = args.options.toVersion ? args.options.toVersion : this.supportedVersions[this.supportedVersions.length - 1];
        this.packageManager = args.options.packageManager || 'npm';
        this.shell = args.options.shell || 'bash';
        if (this.supportedVersions.indexOf(this.toVersion) < 0) {
            cb(new Command_1.CommandError(`Office 365 CLI doesn't support upgrading SharePoint Framework projects to version ${this.toVersion}. Supported versions are ${this.supportedVersions.join(', ')}`, SpfxProjectUpgradeCommand.ERROR_UNSUPPORTED_TO_VERSION));
            return;
        }
        this.projectVersion = this.getProjectVersion();
        if (!this.projectVersion) {
            cb(new Command_1.CommandError(`Unable to determine the version of the current SharePoint Framework project`, SpfxProjectUpgradeCommand.ERROR_NO_VERSION));
            return;
        }
        const pos = this.supportedVersions.indexOf(this.projectVersion);
        if (pos < 0) {
            cb(new Command_1.CommandError(`Office 365 CLI doesn't support upgrading projects build on SharePoint Framework v${this.projectVersion}`, SpfxProjectUpgradeCommand.ERROR_UNSUPPORTED_FROM_VERSION));
            return;
        }
        const posTo = this.supportedVersions.indexOf(this.toVersion);
        if (pos > posTo) {
            cb(new Command_1.CommandError('You cannot downgrade a project', SpfxProjectUpgradeCommand.ERROR_NO_DOWNGRADE));
            return;
        }
        if (pos === posTo) {
            cb(new Command_1.CommandError('Project doesn\'t need to be upgraded', SpfxProjectUpgradeCommand.ERROR_PROJECT_UP_TO_DATE));
            return;
        }
        if (this.verbose) {
            cmd.log('Collecting project...');
        }
        const project = this.getProject(this.projectRootPath);
        if (this.debug) {
            cmd.log('Collected project');
            cmd.log(project);
        }
        // reverse the list of versions to upgrade to, so that most recent findings
        // will end up on top already. Saves us reversing a larger array later
        const versionsToUpgradeTo = this.supportedVersions.slice(pos + 1, posTo + 1).reverse();
        try {
            versionsToUpgradeTo.forEach(v => {
                const rules = require(`./project-upgrade/upgrade-${v}`);
                rules.forEach(r => {
                    r.visit(project, this.allFindings);
                });
            });
        }
        catch (e) {
            cb(new Command_1.CommandError(e.message));
            return;
        }
        if (this.packageManager === 'npm') {
            const npmDedupeRule = new FN017001_MISC_npm_dedupe_1.FN017001_MISC_npm_dedupe();
            npmDedupeRule.visit(project, this.allFindings);
        }
        // dedupe
        const findings = this.allFindings.filter((f, i, allFindings) => {
            const firstFindingPos = this.allFindings.findIndex(f1 => f1.id === f.id);
            return i === firstFindingPos;
        });
        // remove superseded findings
        findings
            // get findings that supersede other findings
            .filter(f => f.supersedes.length > 0)
            .forEach(f => {
            f.supersedes.forEach(s => {
                // find the superseded finding
                const i = findings.findIndex(f1 => f1.id === s);
                if (i > -1) {
                    // ...and remove it from findings
                    findings.splice(i, 1);
                }
            });
        });
        // flatten
        const findingsToReport = [].concat.apply([], findings.map(f => {
            return f.occurrences.map(o => {
                return {
                    description: f.description,
                    id: f.id,
                    file: o.file,
                    position: o.position,
                    resolution: o.resolution,
                    resolutionType: f.resolutionType,
                    severity: f.severity,
                    title: f.title
                };
            });
        }));
        // replace package operation tokens with command for the specific package manager
        findingsToReport.forEach(f => {
            // matches must be in this particular order to avoid false matches, eg.
            // uninstallDev contains install
            if (f.resolution.startsWith('uninstallDev')) {
                f.resolution = f.resolution.replace('uninstallDev', this.getPackageManagerCommand('uninstallDev'));
                return;
            }
            if (f.resolution.startsWith('installDev')) {
                f.resolution = f.resolution.replace('installDev', this.getPackageManagerCommand('installDev'));
                return;
            }
            if (f.resolution.startsWith('uninstall')) {
                f.resolution = f.resolution.replace('uninstall', this.getPackageManagerCommand('uninstall'));
                return;
            }
            if (f.resolution.startsWith('install')) {
                f.resolution = f.resolution.replace('install', this.getPackageManagerCommand('install'));
                return;
            }
            // copy support for multiple shells
            if (f.resolution.startsWith('copy_cmd')) {
                f.resolution = f.resolution.replace('copy_cmd', this.getCopyCommand('copyCommand'));
                f.resolution = f.resolution.replace('DestinationParam', this.getCopyCommand('copyDestinationParam'));
                return;
            }
            // createdir support for multiple shells
            if (f.resolution.startsWith('create_dir_cmd')) {
                f.resolution = f.resolution.replace('create_dir_cmd', this.getDirectoryCommand('createDirectoryCommand'));
                f.resolution = f.resolution.replace('NameParam', this.getDirectoryCommand('createDirectoryNameParam'));
                f.resolution = f.resolution.replace('PathParam', this.getDirectoryCommand('createDirectoryPathParam'));
                f.resolution = f.resolution.replace('ItemTypeParam', this.getDirectoryCommand('createDirectoryItemTypeParam'));
                return;
            }
            // 'Add' support for multiple shells
            if (f.resolution.startsWith('add_cmd')) {
                const pathStart = f.resolution.indexOf('[BEFOREPATH]') + '[BEFOREPATH]'.length;
                const pathEnd = f.resolution.indexOf('[AFTERPATH]');
                const filePath = f.resolution.substring(pathStart, pathEnd);
                const contentStart = f.resolution.indexOf('[BEFORECONTENT]') + '[BEFORECONTENT]'.length;
                const contentEnd = f.resolution.indexOf('[AFTERCONTENT]');
                const fileContent = f.resolution.substring(contentStart, contentEnd);
                f.resolution = this.getAddCommand('addFileCommand');
                f.resolution = f.resolution.replace('[FILECONTENT]', fileContent);
                f.resolution = f.resolution.replace('[FILEPATH]', filePath);
                f.resolution = f.resolution.replace('[BEFOREPATH]', ' ');
                f.resolution = f.resolution.replace('[AFTERPATH]', ' ');
                f.resolution = f.resolution.replace('[BEFORECONTENT]', ' ');
                f.resolution = f.resolution.replace('[AFTERCONTENT]', ' ');
                return;
            }
            // 'Remove' support for multiple shells
            if (f.resolution.startsWith('remove_cmd')) {
                f.resolution = f.resolution.replace('remove_cmd', this.getRemoveCommand('removeFileCommand'));
                return;
            }
        });
        switch (args.options.output) {
            case 'json':
                this.writeReport(findingsToReport, cmd, args.options);
                break;
            case 'md':
                this.writeReport(this.getMdReport(findingsToReport), cmd, args.options);
                break;
            default:
                this.writeReport(this.getTextReport(findingsToReport), cmd, args.options);
        }
        cb();
    }
    writeReport(findingsToReport, cmd, options) {
        if (options.outputFile) {
            fs.writeFileSync(path.resolve(options.outputFile), options.output === 'json' ? JSON.stringify(findingsToReport) : findingsToReport, 'utf-8');
        }
        else {
            cmd.log(findingsToReport);
        }
    }
    getTextReport(findings) {
        const reportData = this.getReportData(findings);
        const s = [
            'Execute in ' + this.shell, os.EOL,
            '-----------------------', os.EOL,
            (reportData.packageManagerCommands
                .concat(reportData.commandsToExecute
                .filter((command) => command.indexOf(this.getPackageManagerCommand('install')) === -1 &&
                command.indexOf(this.getPackageManagerCommand('installDev')) === -1 &&
                command.indexOf(this.getPackageManagerCommand('uninstall')) === -1 &&
                command.indexOf(this.getPackageManagerCommand('uninstallDev')) === -1))).join(os.EOL), os.EOL,
            os.EOL,
            Object.keys(reportData.modificationPerFile).map(file => {
                return [
                    file, os.EOL,
                    '-'.repeat(file.length), os.EOL,
                    reportData.modificationPerFile[file].map((m) => `${m.description}:${os.EOL}${m.modification}${os.EOL}`).join(os.EOL), os.EOL,
                ].join('');
            }).join(os.EOL),
            os.EOL,
        ];
        return s.join('').trim();
    }
    getMdReport(findings) {
        const findingsToReport = [];
        const reportData = this.getReportData(findings);
        findings.forEach(f => {
            let resolution = '';
            switch (f.resolutionType) {
                case 'cmd':
                    resolution = `Execute the following command:

\`\`\`sh
${f.resolution}
\`\`\`
`;
                    break;
                case 'json':
                case 'js':
                case 'ts':
                case 'scss':
                    resolution = `In file [${f.file}](${f.file}) update the code as follows:

\`\`\`${f.resolutionType}
${f.resolution}
\`\`\`
`;
                    break;
            }
            findingsToReport.push(`### ${f.id} ${f.title} | ${f.severity}`, os.EOL, os.EOL, f.description, os.EOL, os.EOL, resolution, os.EOL, `File: [${f.file}${(f.position ? `:${f.position.line}:${f.position.character}` : '')}](${f.file})`, os.EOL, os.EOL);
        });
        const s = [
            `# Upgrade project ${path.posix.basename(this.projectRootPath)} to v${this.toVersion}`, os.EOL,
            os.EOL,
            `Date: ${(new Date().toLocaleDateString())}`, os.EOL,
            os.EOL,
            '## Findings', os.EOL,
            os.EOL,
            `Following is the list of steps required to upgrade your project to SharePoint Framework version ${this.toVersion}. [Summary](#Summary) of the modifications is included at the end of the report.`, os.EOL,
            os.EOL,
            findingsToReport.join(''),
            '## Summary', os.EOL,
            os.EOL,
            '### Execute script', os.EOL,
            os.EOL,
            '```sh', os.EOL,
            (reportData.packageManagerCommands
                .concat(reportData.commandsToExecute
                .filter((command) => command.indexOf(this.getPackageManagerCommand('install')) === -1 &&
                command.indexOf(this.getPackageManagerCommand('installDev')) === -1 &&
                command.indexOf(this.getPackageManagerCommand('uninstall')) === -1 &&
                command.indexOf(this.getPackageManagerCommand('uninstallDev')) === -1))).join(os.EOL), os.EOL,
            '```', os.EOL,
            os.EOL,
            '### Modify files', os.EOL,
            os.EOL,
            Object.keys(reportData.modificationPerFile).map(file => {
                return [
                    `#### [${file}](${file})`, os.EOL,
                    os.EOL,
                    reportData.modificationPerFile[file].map((m) => `${m.description}:${os.EOL}${os.EOL}\`\`\`${reportData.modificationTypePerFile[file]}${os.EOL}${m.modification}${os.EOL}\`\`\``).join(os.EOL + os.EOL), os.EOL,
                ].join('');
            }).join(os.EOL),
            os.EOL,
        ];
        return s.join('').trim();
    }
    getReportData(findings) {
        const commandsToExecute = [];
        const modificationPerFile = {};
        const modificationTypePerFile = {};
        const packagesDevExact = [];
        const packagesDepExact = [];
        const packagesDepUn = [];
        const packagesDevUn = [];
        findings.forEach(f => {
            if (f.resolutionType === 'cmd') {
                if (f.resolution.indexOf('npm') > -1 ||
                    f.resolution.indexOf('yarn') > -1) {
                    this.mapPackageManagerCommand(f.resolution, packagesDevExact, packagesDepExact, packagesDepUn, packagesDevUn);
                }
                else {
                    commandsToExecute.push(f.resolution);
                }
            }
            else {
                if (!modificationPerFile[f.file]) {
                    modificationPerFile[f.file] = [];
                }
                if (!modificationTypePerFile[f.file]) {
                    modificationTypePerFile[f.file] = f.resolutionType;
                }
                modificationPerFile[f.file].push({
                    description: f.description,
                    modification: f.resolution
                });
            }
        });
        const packageManagerCommands = this.reducePackageManagerCommand(packagesDepExact, packagesDevExact, packagesDepUn, packagesDevUn);
        return {
            commandsToExecute: commandsToExecute,
            packageManagerCommands: packageManagerCommands,
            modificationPerFile: modificationPerFile,
            modificationTypePerFile: modificationTypePerFile
        };
    }
    mapPackageManagerCommand(command, packagesDevExact, packagesDepExact, packagesDepUn, packagesDevUn) {
        // matches must be in this particular order to avoid false matches, eg.
        // uninstallDev contains install
        if (command.startsWith(`${this.getPackageManagerCommand('uninstallDev')} `)) {
            packagesDevUn.push(command.replace(this.getPackageManagerCommand('uninstallDev'), '').trim());
            return;
        }
        if (command.startsWith(`${this.getPackageManagerCommand('installDev')} `)) {
            packagesDevExact.push(command.replace(this.getPackageManagerCommand('installDev'), '').trim());
            return;
        }
        if (command.startsWith(`${this.getPackageManagerCommand('uninstall')} `)) {
            packagesDepUn.push(command.replace(this.getPackageManagerCommand('uninstall'), '').trim());
            return;
        }
        if (command.startsWith(`${this.getPackageManagerCommand('install')} `)) {
            packagesDepExact.push(command.replace(this.getPackageManagerCommand('install'), '').trim());
        }
    }
    reducePackageManagerCommand(packagesDepExact, packagesDevExact, packagesDepUn, packagesDevUn) {
        const commandsToExecute = [];
        if (packagesDepExact.length > 0) {
            commandsToExecute.push(`${this.getPackageManagerCommand('install')} ${packagesDepExact.join(' ')}`);
        }
        if (packagesDevExact.length > 0) {
            commandsToExecute.push(`${this.getPackageManagerCommand('installDev')} ${packagesDevExact.join(' ')}`);
        }
        if (packagesDepUn.length > 0) {
            commandsToExecute.push(`${this.getPackageManagerCommand('uninstall')} ${packagesDepUn.join(' ')}`);
        }
        if (packagesDevUn.length > 0) {
            commandsToExecute.push(`${this.getPackageManagerCommand('uninstallDev')} ${packagesDevUn.join(' ')}`);
        }
        return commandsToExecute;
    }
    getPackageManagerCommand(command) {
        return SpfxProjectUpgradeCommand.packageCommands[this.packageManager][command];
    }
    getCopyCommand(command) {
        return SpfxProjectUpgradeCommand.copyCommands[this.shell][command];
    }
    getDirectoryCommand(command) {
        return SpfxProjectUpgradeCommand.createDirectoryCommands[this.shell][command];
    }
    getAddCommand(command) {
        return SpfxProjectUpgradeCommand.addFileCommands[this.shell][command];
    }
    getRemoveCommand(command) {
        return SpfxProjectUpgradeCommand.removeFileCommands[this.shell][command];
    }
    options() {
        const options = [
            {
                option: '-v, --toVersion [toVersion]',
                description: 'The version of SharePoint Framework to which upgrade the project'
            },
            {
                option: '--packageManager [packageManager]',
                description: 'The package manager you use. Supported managers npm|pnpm|yarn. Default npm',
                autocomplete: ['npm', 'pnpm', 'yarn']
            },
            {
                option: '--shell [shell]',
                description: 'The shell you use. Supported shells bash|powershell|cmd. Default bash',
                autocomplete: ['bash', 'powershell', 'cmd']
            },
            {
                option: '-f, --outputFile [outputFile]',
                description: 'Path to the file where the upgrade report should be stored in'
            }
        ];
        const parentOptions = super.options();
        parentOptions.forEach(o => {
            if (o.option.indexOf('--output') > -1) {
                o.description = 'Output type. json|text|md. Default text';
                o.autocomplete = ['json', 'text', 'md'];
            }
        });
        return options.concat(parentOptions);
    }
    validate() {
        return (args) => {
            if (args.options.packageManager) {
                if (['npm', 'pnpm', 'yarn'].indexOf(args.options.packageManager) < 0) {
                    return `${args.options.packageManager} is not a supported package manager. Supported package managers are npm, pnpm and yarn`;
                }
            }
            if (args.options.shell) {
                if (['bash', 'powershell', 'cmd'].indexOf(args.options.shell) < 0) {
                    return `${args.options.shell} is not a supported shell. Supported shells are bash, powershell and cmd`;
                }
            }
            if (args.options.outputFile) {
                const dirPath = path.dirname(path.resolve(args.options.outputFile));
                if (!fs.existsSync(dirPath)) {
                    return `Directory ${dirPath} doesn't exist. Please check the path and try again.`;
                }
            }
            return true;
        };
    }
    commandHelp(args, log) {
        const chalk = vorpal.chalk;
        log(vorpal.find(commands_1.default.PROJECT_UPGRADE).helpInformation());
        log(`   ${chalk.yellow('Important:')} Run this command in the folder where the project
    that you want to upgrade is located. This command doesn't change your
    project files.
      
  Remarks:

    The ${this.name} command helps you upgrade your SharePoint Framework
    project to the specified version. If no version is specified, the command
    will upgrade to the latest version of the SharePoint Framework it supports
    (v1.10.0).

    This command doesn't change your project files. Instead, it gives you
    a report with all steps necessary to upgrade your project to the specified
    version of the SharePoint Framework. Changing project files is error-prone,
    especially when it comes to updating your solution's code. This is why at
    this moment, this command produces a report that you can use yourself to
    perform the necessary updates and verify that everything is working as
    expected.

    Using this command you can upgrade SharePoint Framework projects built using
    versions: 1.0.0, 1.0.1, 1.0.2, 1.1.0, 1.1.1, 1.1.3, 1.2.0, 1.3.0, 1.3.1,
    1.3.2, 1.3.4, 1.4.0, 1.4.1, 1.5.0, 1.5.1, 1.6.0, 1.7.0, 1.7.1, 1.8.0,
    1.8.1, 1.8.2 and 1.9.1.

  Examples:
  
    Get instructions to upgrade the current SharePoint Framework project to
    SharePoint Framework version 1.5.0 and save the findings in a Markdown file
      ${this.name} --toVersion 1.5.0 --output md --outputFile upgrade-report.md

    Get instructions to Upgrade the current SharePoint Framework project to
    SharePoint Framework version 1.5.0 and show the summary of the findings
    in the shell
      ${this.name} --toVersion 1.5.0

    Get instructions to upgrade the current SharePoint Framework project to the
    latest SharePoint Framework version supported by the Office 365 CLI using
    pnpm
      ${this.name} --packageManager pnpm

    Get instructions to upgrade the current SharePoint Framework project to the
    latest SharePoint Framework version supported by the Office 365 CLI
      ${this.name}

    Get instructions to upgrade the current SharePoint Framework project to the
    latest SharePoint Framework version supported by the Office 365 CLI using
    PowerShell
      ${this.name} --shell powershell
`);
    }
}
SpfxProjectUpgradeCommand.packageCommands = {
    npm: {
        install: 'npm i -SE',
        installDev: 'npm i -DE',
        uninstall: 'npm un -S',
        uninstallDev: 'npm un -D'
    },
    pnpm: {
        install: 'pnpm i -E',
        installDev: 'pnpm i -DE',
        uninstall: 'pnpm un',
        uninstallDev: 'pnpm un'
    },
    yarn: {
        install: 'yarn add -E',
        installDev: 'yarn add -DE',
        uninstall: 'yarn remove',
        uninstallDev: 'yarn remove'
    }
};
SpfxProjectUpgradeCommand.copyCommands = {
    bash: {
        copyCommand: 'cp',
        copyDestinationParam: ' '
    },
    powershell: {
        copyCommand: 'Copy-Item',
        copyDestinationParam: ' -Destination '
    },
    cmd: {
        copyCommand: 'copy',
        copyDestinationParam: ' '
    }
};
SpfxProjectUpgradeCommand.createDirectoryCommands = {
    bash: {
        createDirectoryCommand: 'mkdir',
        createDirectoryPathParam: ' ',
        createDirectoryNameParam: '/',
        createDirectoryItemTypeParam: '',
    },
    powershell: {
        createDirectoryCommand: 'New-Item',
        createDirectoryPathParam: ' -Path "',
        createDirectoryNameParam: '" -Name "',
        createDirectoryItemTypeParam: '" -ItemType "directory"',
    },
    cmd: {
        createDirectoryCommand: 'mkdir',
        createDirectoryPathParam: ' "',
        createDirectoryNameParam: '\\',
        createDirectoryItemTypeParam: '"',
    }
};
SpfxProjectUpgradeCommand.addFileCommands = {
    bash: {
        addFileCommand: 'cat > [FILEPATH] << EOF [FILECONTENT]EOF',
    },
    powershell: {
        addFileCommand: `@"[FILECONTENT]"@ | Out-File -FilePath "[FILEPATH]"
      `,
    },
    cmd: {
        addFileCommand: `echo [FILECONTENT] > "[FILEPATH]"
      `,
    }
};
SpfxProjectUpgradeCommand.removeFileCommands = {
    bash: {
        removeFileCommand: 'rm',
    },
    powershell: {
        removeFileCommand: 'Remove-Item',
    },
    cmd: {
        removeFileCommand: 'del',
    }
};
SpfxProjectUpgradeCommand.ERROR_NO_PROJECT_ROOT_FOLDER = 1;
SpfxProjectUpgradeCommand.ERROR_UNSUPPORTED_TO_VERSION = 2;
SpfxProjectUpgradeCommand.ERROR_NO_VERSION = 3;
SpfxProjectUpgradeCommand.ERROR_UNSUPPORTED_FROM_VERSION = 4;
SpfxProjectUpgradeCommand.ERROR_NO_DOWNGRADE = 5;
SpfxProjectUpgradeCommand.ERROR_PROJECT_UP_TO_DATE = 6;
module.exports = new SpfxProjectUpgradeCommand();
//# sourceMappingURL=project-upgrade.js.map