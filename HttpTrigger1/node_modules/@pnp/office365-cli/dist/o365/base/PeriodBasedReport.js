"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GraphCommand_1 = require("./GraphCommand");
const request_1 = require("../../request");
const path = require("path");
const fs = require("fs");
class PeriodBasedReport extends GraphCommand_1.default {
    getTelemetryProperties(args) {
        const telemetryProps = super.getTelemetryProperties(args);
        telemetryProps.outputFile = typeof args.options.outputFile !== 'undefined';
        return telemetryProps;
    }
    commandAction(cmd, args, cb) {
        const endpoint = `${this.resource}/v1.0/reports/${this.usageEndpoint}(period='${encodeURIComponent(args.options.period)}')`;
        this.executeReport(endpoint, cmd, args.options.output, args.options.outputFile, cb);
    }
    executeReport(endPoint, cmd, output, outputFile, cb) {
        const requestOptions = {
            url: endPoint,
            headers: {
                accept: 'application/json;odata.metadata=none'
            },
            json: true
        };
        request_1.default
            .get(requestOptions)
            .then((res) => {
            let content = '';
            let cleanResponse = this.removeEmptyLines(res);
            if (output && output.toLowerCase() === 'json') {
                const reportData = this.getReport(cleanResponse);
                content = JSON.stringify(reportData);
            }
            else {
                content = cleanResponse;
            }
            if (!outputFile) {
                cmd.log(content);
            }
            else {
                fs.writeFileSync(outputFile, content, 'utf8');
                if (this.verbose) {
                    cmd.log(`File saved to path '${outputFile}'`);
                }
            }
            cb();
        }, (err) => this.handleRejectedODataJsonPromise(err, cmd, cb));
    }
    removeEmptyLines(input) {
        const rows = input.split('\n');
        const cleanRows = rows.filter(Boolean);
        return cleanRows.join('\n');
    }
    getReport(res) {
        const rows = res.split('\n');
        const jsonObj = [];
        const headers = rows[0].split(',');
        for (let i = 1; i < rows.length; i++) {
            const data = rows[i].split(',');
            let obj = {};
            for (let j = 0; j < data.length; j++) {
                obj[headers[j].trim()] = data[j].trim();
            }
            jsonObj.push(obj);
        }
        return jsonObj;
    }
    options() {
        const options = [
            {
                option: '-p, --period <period>',
                description: 'The length of time over which the report is aggregated. Supported values D7,D30,D90,D180',
                autocomplete: ['D7', 'D30', 'D90', 'D180']
            },
            {
                option: '-f, --outputFile [outputFile]',
                description: 'Path to the file where the report should be stored in'
            }
        ];
        const parentOptions = super.options();
        return options.concat(parentOptions);
    }
    validate() {
        return (args) => {
            if (!args.options.period) {
                return 'Required parameter period missing';
            }
            if (args.options.outputFile && !fs.existsSync(path.dirname(args.options.outputFile))) {
                return `The specified path ${path.dirname(args.options.outputFile)} doesn't exist`;
            }
            return this.validatePeriod(args.options.period);
        };
    }
    validatePeriod(period) {
        if (period &&
            ['D7', 'D30', 'D90', 'D180'].indexOf(period) < 0) {
            return `${period} is not a valid period type. The supported values are D7|D30|D90|D180`;
        }
        return true;
    }
}
exports.default = PeriodBasedReport;
//# sourceMappingURL=PeriodBasedReport.js.map