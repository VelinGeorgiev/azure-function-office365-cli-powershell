"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Command_1 = require("../../Command");
const Auth_1 = require("../../Auth");
const request_1 = require("../../request");
const config_1 = require("../../config");
const csomDefs = require('../../../csom.json');
class SpoCommand extends Command_1.default {
    getRequestDigest(siteUrl) {
        const requestOptions = {
            url: `${siteUrl}/_api/contextinfo`,
            headers: {
                accept: 'application/json;odata=nometadata'
            },
            json: true
        };
        return request_1.default.post(requestOptions);
    }
    static isValidSharePointUrl(url) {
        if (!url) {
            return false;
        }
        if (url.indexOf('https://') !== 0) {
            return `${url} is not a valid SharePoint Online site URL`;
        }
        else {
            return true;
        }
    }
    ensureFormDigest(siteUrl, cmd, context, debug) {
        return new Promise((resolve, reject) => {
            if (this.isValidFormDigest(context)) {
                if (debug) {
                    cmd.log('Existing form digest still valid');
                }
                resolve(context);
                return;
            }
            this
                .getRequestDigest(siteUrl)
                .then((res) => {
                const now = new Date();
                now.setSeconds(now.getSeconds() + res.FormDigestTimeoutSeconds - 5);
                context = {
                    FormDigestValue: res.FormDigestValue,
                    FormDigestTimeoutSeconds: res.FormDigestTimeoutSeconds,
                    FormDigestExpiresAt: now,
                    WebFullUrl: res.WebFullUrl
                };
                resolve(context);
            }, (error) => {
                reject(error);
            });
        });
    }
    isValidFormDigest(contextInfo) {
        if (!contextInfo) {
            return false;
        }
        const now = new Date();
        if (contextInfo.FormDigestValue && now < contextInfo.FormDigestExpiresAt) {
            return true;
        }
        return false;
    }
    waitUntilFinished(operationId, siteUrl, resolve, reject, cmd, currentContext, dots, timeout) {
        this
            .ensureFormDigest(siteUrl, cmd, currentContext, this.debug)
            .then((res) => {
            currentContext = res;
            if (this.debug) {
                cmd.log(`Checking if operation ${operationId} completed...`);
            }
            if (!this.debug && this.verbose) {
                dots += '.';
                process.stdout.write(`\r${dots}`);
            }
            const requestOptions = {
                url: `${siteUrl}/_vti_bin/client.svc/ProcessQuery`,
                headers: {
                    'X-RequestDigest': currentContext.FormDigestValue
                },
                body: `<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="${config_1.default.applicationName}" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><Query Id="188" ObjectPathId="184"><Query SelectAllProperties="false"><Properties><Property Name="IsComplete" ScalarProperty="true" /><Property Name="PollingInterval" ScalarProperty="true" /></Properties></Query></Query></Actions><ObjectPaths><Identity Id="184" Name="${operationId.replace(/\\n/g, '&#xA;').replace(/"/g, '')}" /></ObjectPaths></Request>`
            };
            return request_1.default.post(requestOptions);
        })
            .then((res) => {
            const json = JSON.parse(res);
            const response = json[0];
            if (response.ErrorInfo) {
                reject(response.ErrorInfo.ErrorMessage);
            }
            else {
                const operation = json[json.length - 1];
                let isComplete = operation.IsComplete;
                if (isComplete) {
                    if (this.verbose) {
                        process.stdout.write('\n');
                    }
                    resolve();
                    return;
                }
                timeout = setTimeout(() => {
                    this.waitUntilFinished(JSON.stringify(operation._ObjectIdentity_), siteUrl, resolve, reject, cmd, currentContext, dots);
                }, operation.PollingInterval);
            }
        });
    }
    getSpoUrl(stdout, debug) {
        if (Auth_1.default.service.spoUrl) {
            if (debug) {
                stdout.log(`SPO URL previously retrieved ${Auth_1.default.service.spoUrl}. Returning...`);
            }
            return Promise.resolve(Auth_1.default.service.spoUrl);
        }
        return new Promise((resolve, reject) => {
            if (debug) {
                stdout.log(`No SPO URL available. Retrieving from MS Graph...`);
            }
            const requestOptions = {
                url: `https://graph.microsoft.com/v1.0/sites/root?$select=webUrl`,
                headers: {
                    'accept': 'application/json;odata.metadata=none'
                },
                json: true
            };
            request_1.default
                .get(requestOptions)
                .then((res) => {
                Auth_1.default.service.spoUrl = res.webUrl;
                return Auth_1.default.storeConnectionInfo();
            })
                .then(() => {
                resolve(Auth_1.default.service.spoUrl);
            }, (err) => {
                if (Auth_1.default.service.spoUrl) {
                    resolve(Auth_1.default.service.spoUrl);
                }
                else {
                    reject(err);
                }
            });
        });
    }
    getSpoAdminUrl(stdout, debug) {
        return new Promise((resolve, reject) => {
            this
                .getSpoUrl(stdout, debug)
                .then((spoUrl) => {
                resolve(spoUrl.replace(/(https:\/\/)([^\.]+)(.*)/, '$1$2-admin$3'));
            }, (error) => {
                reject(error);
            });
        });
    }
    getTenantId(stdout, debug) {
        if (Auth_1.default.service.tenantId) {
            if (debug) {
                stdout.log(`SPO Tenant ID previously retrieved ${Auth_1.default.service.tenantId}. Returning...`);
            }
            return Promise.resolve(Auth_1.default.service.tenantId);
        }
        return new Promise((resolve, reject) => {
            if (debug) {
                stdout.log(`No SPO Tenant ID available. Retrieving...`);
            }
            let spoAdminUrl = '';
            this
                .getSpoAdminUrl(stdout, debug)
                .then((_spoAdminUrl) => {
                spoAdminUrl = _spoAdminUrl;
                return this.getRequestDigest(spoAdminUrl);
            })
                .then((contextInfo) => {
                const tenantInfoRequestOptions = {
                    url: `${spoAdminUrl}/_vti_bin/client.svc/ProcessQuery`,
                    headers: {
                        'X-RequestDigest': contextInfo.FormDigestValue,
                        accept: 'application/json;odata=nometadata'
                    },
                    body: `<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="${config_1.default.applicationName}" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><ObjectPath Id="4" ObjectPathId="3" /><Query Id="5" ObjectPathId="3"><Query SelectAllProperties="true"><Properties /></Query></Query></Actions><ObjectPaths><Constructor Id="3" TypeId="{268004ae-ef6b-4e9b-8425-127220d84719}" /></ObjectPaths></Request>`
                };
                return request_1.default.post(tenantInfoRequestOptions);
            })
                .then((res) => {
                const json = JSON.parse(res);
                Auth_1.default.service.tenantId = json[json.length - 1]._ObjectIdentity_.replace('\n', '&#xA;');
                return Auth_1.default.storeConnectionInfo();
            })
                .then(() => {
                resolve(Auth_1.default.service.tenantId);
            }, (err) => {
                if (Auth_1.default.service.tenantId) {
                    resolve(Auth_1.default.service.tenantId);
                }
                else {
                    reject(err);
                }
            });
        });
    }
    validateUnknownOptions(options, csomObject, csomPropertyType) {
        const unknownOptions = this.getUnknownOptions(options);
        const optionNames = Object.getOwnPropertyNames(unknownOptions);
        if (optionNames.length === 0) {
            return true;
        }
        for (let i = 0; i < optionNames.length; i++) {
            const optionName = optionNames[i];
            const csomOptionType = csomDefs[csomObject][csomPropertyType][optionName];
            if (!csomOptionType) {
                return `${optionName} is not a valid ${csomObject} property`;
            }
            if (['Boolean', 'String', 'Int32'].indexOf(csomOptionType) < 0) {
                return `Unknown properties of type ${csomOptionType} are not yet supported`;
            }
        }
        return true;
    }
}
exports.default = SpoCommand;
//# sourceMappingURL=SpoCommand.js.map