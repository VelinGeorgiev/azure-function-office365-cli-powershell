"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = require("../../commands");
const request_1 = require("../../../../request");
const SpoCommand_1 = require("../../../base/SpoCommand");
const url = require("url");
const vorpal = require('../../../../vorpal-init');
class SpoFileCopyCommand extends SpoCommand_1.default {
    get name() {
        return commands_1.default.FILE_COPY;
    }
    get description() {
        return 'Copies a file to another location';
    }
    getTelemetryProperties(args) {
        const telemetryProps = super.getTelemetryProperties(args);
        telemetryProps.deleteIfAlreadyExists = args.options.deleteIfAlreadyExists || false;
        return telemetryProps;
    }
    commandAction(cmd, args, cb) {
        const webUrl = args.options.webUrl;
        const parsedUrl = url.parse(webUrl);
        const tenantUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}`;
        // Check if the source file exists.
        // Called on purpose, we explicitly check if user specified file
        // in the sourceUrl option. 
        // The CreateCopyJobs endpoint accepts file, folder or batch from both.
        // A user might enter folder instead of file as source url by mistake
        // then there are edge cases when deleteIfAlreadyExists flag is set
        // the user can receive misleading error message.
        this
            .fileExists(tenantUrl, webUrl, args.options.sourceUrl)
            .then(() => {
            if (args.options.deleteIfAlreadyExists) {
                // try delete target file, if deleteIfAlreadyExists flag is set
                const filename = args.options.sourceUrl.replace(/^.*[\\\/]/, '');
                return this.recycleFile(tenantUrl, args.options.targetUrl, filename, cmd);
            }
            return Promise.resolve();
        })
            .then(() => {
            // all preconditions met, now create copy job
            const sourceAbsoluteUrl = this.urlCombine(webUrl, args.options.sourceUrl);
            const allowSchemaMismatch = args.options.allowSchemaMismatch || false;
            const requestUrl = this.urlCombine(webUrl, '/_api/site/CreateCopyJobs');
            const requestOptions = {
                url: requestUrl,
                headers: {
                    'accept': 'application/json;odata=nometadata'
                },
                body: {
                    exportObjectUris: [sourceAbsoluteUrl],
                    destinationUri: this.urlCombine(tenantUrl, args.options.targetUrl),
                    options: {
                        "AllowSchemaMismatch": allowSchemaMismatch,
                        "IgnoreVersionHistory": true
                    }
                },
                json: true
            };
            return request_1.default.post(requestOptions);
        })
            .then((jobInfo) => {
            const jobProgressOptions = {
                webUrl: webUrl,
                copyJopInfo: jobInfo.value[0],
                progressMaxPollAttempts: 1000,
                progressPollInterval: 30 * 60,
                progressRetryAttempts: 5
            };
            return this.waitForJobResult(jobProgressOptions, cmd);
        })
            .then(() => {
            if (this.verbose) {
                cmd.log('DONE');
            }
            cb();
        }, (err) => this.handleRejectedODataJsonPromise(err, cmd, cb));
    }
    /**
     * Checks if a file exists on the server relative url
     */
    fileExists(tenantUrl, webUrl, sourceUrl) {
        const webServerRelativeUrl = webUrl.replace(tenantUrl, '');
        const fileServerRelativeUrl = `${webServerRelativeUrl}${sourceUrl}`;
        const requestUrl = `${webUrl}/_api/web/GetFileByServerRelativeUrl('${encodeURIComponent(fileServerRelativeUrl)}')/`;
        const requestOptions = {
            url: requestUrl,
            method: 'GET',
            headers: {
                'accept': 'application/json;odata=nometadata'
            },
            json: true
        };
        return request_1.default.get(requestOptions);
    }
    /**
     * A polling function that awaits the
     * queued copy job to return JobStatus = 0 meaning it is done with the task.
     */
    waitForJobResult(opts, cmd) {
        let pollCount = 0;
        let retryAttemptsCount = 0;
        const checkCondition = (resolve, reject) => {
            pollCount++;
            const requestUrl = `${opts.webUrl}/_api/site/GetCopyJobProgress`;
            const requestOptions = {
                url: requestUrl,
                headers: {
                    'accept': 'application/json;odata=nometadata'
                },
                body: { "copyJobInfo": opts.copyJopInfo },
                json: true
            };
            request_1.default.post(requestOptions).then((resp) => {
                retryAttemptsCount = 0; // clear retry on promise success 
                if (this.verbose) {
                    if (resp.JobState && resp.JobState === 4) {
                        cmd.log(`Check #${pollCount}. Copy job in progress... JobState: ${resp.JobState}`);
                    }
                    else {
                        cmd.log(`Check #${pollCount}. JobState: ${resp.JobState}`);
                    }
                }
                for (const item of resp.Logs) {
                    const log = JSON.parse(item);
                    // reject if progress error 
                    if (log.Event === "JobError" || log.Event === "JobFatalError") {
                        return reject(log.Message);
                    }
                }
                // three possible scenarios
                // job done = success promise returned
                // job in progress = recursive call using setTimeout returned
                // max poll attempts flag raised = reject promise returned
                if (resp.JobState === 0) {
                    // job done
                    resolve();
                    return;
                }
                if (pollCount < opts.progressMaxPollAttempts) {
                    // if the condition isn't met but the timeout hasn't elapsed, go again
                    setTimeout(checkCondition, opts.progressPollInterval, resolve, reject);
                }
                else {
                    reject(new Error('waitForJobResult timed out'));
                }
            }, (error) => {
                retryAttemptsCount++;
                // let's retry x times in row before we give up since
                // this is progress check and even if rejects a promise
                // the actual copy process can success.
                if (retryAttemptsCount <= opts.progressRetryAttempts) {
                    setTimeout(checkCondition, opts.progressPollInterval, resolve, reject);
                }
                else {
                    reject(error);
                }
            });
        };
        return new Promise(checkCondition);
    }
    /**
     * Moves file in the site recycle bin
     */
    recycleFile(tenantUrl, targetUrl, filename, cmd) {
        return new Promise((resolve, reject) => {
            const targetFolderAbsoluteUrl = this.urlCombine(tenantUrl, targetUrl);
            // since the target WebFullUrl is unknown we can use getRequestDigestForSite
            // to get it from target folder absolute url.
            // Similar approach used here Microsoft.SharePoint.Client.Web.WebUrlFromFolderUrlDirect
            this
                .getRequestDigest(targetFolderAbsoluteUrl)
                .then((contextResponse) => {
                if (this.debug) {
                    cmd.log(`contextResponse.WebFullUrl: ${contextResponse.WebFullUrl}`);
                }
                if (targetUrl.charAt(0) !== '/') {
                    targetUrl = `/${targetUrl}`;
                }
                if (targetUrl.lastIndexOf('/') !== targetUrl.length - 1) {
                    targetUrl = `${targetUrl}/`;
                }
                const requestUrl = `${contextResponse.WebFullUrl}/_api/web/GetFileByServerRelativeUrl('${encodeURIComponent(`${targetUrl}${filename}`)}')/recycle()`;
                const requestOptions = {
                    url: requestUrl,
                    method: 'POST',
                    headers: {
                        'X-HTTP-Method': 'DELETE',
                        'If-Match': '*',
                        'accept': 'application/json;odata=nometadata'
                    },
                    json: true
                };
                request_1.default.post(requestOptions)
                    .then(() => {
                    resolve();
                })
                    .catch((err) => {
                    if (err.statusCode === 404) {
                        // file does not exist so can proceed
                        return resolve();
                    }
                    if (this.debug) {
                        cmd.log(`recycleFile error...`);
                        cmd.log(err);
                    }
                    reject(err);
                });
            }, (e) => reject(e));
        });
    }
    /**
     * Combines base and relative url considering any missing slashes
     * @param baseUrl https://contoso.com
     * @param relativeUrl sites/abc
     */
    urlCombine(baseUrl, relativeUrl) {
        // remove last '/' of base if exists
        if (baseUrl.lastIndexOf('/') === baseUrl.length - 1) {
            baseUrl = baseUrl.substring(0, baseUrl.length - 1);
        }
        // remove '/' at 0
        if (relativeUrl.charAt(0) === '/') {
            relativeUrl = relativeUrl.substring(1, relativeUrl.length);
        }
        // remove last '/' of next if exists
        if (relativeUrl.lastIndexOf('/') === relativeUrl.length - 1) {
            relativeUrl = relativeUrl.substring(0, relativeUrl.length - 1);
        }
        return `${baseUrl}/${relativeUrl}`;
    }
    options() {
        const options = [
            {
                option: '-u, --webUrl <webUrl>',
                description: 'The URL of the site where the file is located'
            },
            {
                option: '-s, --sourceUrl <sourceUrl>',
                description: 'Site-relative URL of the file to copy'
            },
            {
                option: '-t, --targetUrl <targetUrl>',
                description: 'Server-relative URL where to copy the file'
            },
            {
                option: '--deleteIfAlreadyExists',
                description: 'If a file already exists at the targetUrl, it will be moved to the recycle bin. If omitted, the copy operation will be canceled if the file already exists at the targetUrl location'
            },
            {
                option: '--allowSchemaMismatch',
                description: 'Ignores any missing fields in the target document library and copies the file anyway'
            }
        ];
        const parentOptions = super.options();
        return options.concat(parentOptions);
    }
    validate() {
        return (args) => {
            if (!args.options.webUrl) {
                return 'Required parameter webUrl missing';
            }
            const isValidSharePointUrl = SpoCommand_1.default.isValidSharePointUrl(args.options.webUrl);
            if (isValidSharePointUrl !== true) {
                return isValidSharePointUrl;
            }
            if (!args.options.sourceUrl) {
                return 'Required parameter sourceUrl missing';
            }
            if (!args.options.targetUrl) {
                return 'Required parameter targetUrl missing';
            }
            return true;
        };
    }
    commandHelp(args, log) {
        const chalk = vorpal.chalk;
        log(vorpal.find(this.name).helpInformation());
        log(`  Remarks:
  
    When you copy a file using the ${chalk.grey(this.name)} command,
    only the latest version of the file is copied.
        
  Examples:
  
    Copy file to a document library in another site collection
      ${commands_1.default.FILE_COPY} --webUrl https://contoso.sharepoint.com/sites/test1 --sourceUrl /Shared%20Documents/sp1.pdf --targetUrl /sites/test2/Shared%20Documents/

    Copy file to a document library in the same site collection
      ${commands_1.default.FILE_COPY} --webUrl https://contoso.sharepoint.com/sites/test1 --sourceUrl /Shared%20Documents/sp1.pdf --targetUrl /sites/test1/HRDocuments/

    Copy file to a document library in another site collection. If a file with
    the same name already exists in the target document library, move it
    to the recycle bin
      ${commands_1.default.FILE_COPY} --webUrl https://contoso.sharepoint.com/sites/test1 --sourceUrl /Shared%20Documents/sp1.pdf --targetUrl /sites/test2/Shared%20Documents/ --deleteIfAlreadyExists
  
    Copy file to a document library in another site collection. Will ignore
    any missing fields in the target destination and copy anyway
      ${commands_1.default.FILE_COPY} --webUrl https://contoso.sharepoint.com/sites/test1 --sourceUrl /Shared%20Documents/sp1.pdf --targetUrl /sites/test2/Shared%20Documents/ --allowSchemaMismatch

  More information:

    Copy items from a SharePoint document library
      https://support.office.com/en-us/article/move-or-copy-items-from-a-sharepoint-document-library-00e2f483-4df3-46be-a861-1f5f0c1a87bc
    `);
    }
}
module.exports = new SpoFileCopyCommand();
//# sourceMappingURL=file-copy.js.map