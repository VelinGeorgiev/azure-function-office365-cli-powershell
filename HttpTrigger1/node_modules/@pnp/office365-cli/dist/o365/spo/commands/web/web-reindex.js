"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = require("../../commands");
const request_1 = require("../../../../request");
const SpoCommand_1 = require("../../../base/SpoCommand");
const propertybag_base_1 = require("../propertybag/propertybag-base");
const ClientSvc_1 = require("../../ClientSvc");
const vorpal = require('../../../../vorpal-init');
class SpoWebReindexCommand extends SpoCommand_1.default {
    constructor() {
        super();
        this.reindexedLists = false;
    }
    get name() {
        return commands_1.default.WEB_REINDEX;
    }
    get description() {
        return 'Requests reindexing the specified subsite';
    }
    commandAction(cmd, args, cb) {
        const clientSvcCommons = new ClientSvc_1.ClientSvc(cmd, this.debug);
        let requestDigest = '';
        let webIdentityResp;
        this
            .getRequestDigest(args.options.webUrl)
            .then((res) => {
            requestDigest = res.FormDigestValue;
            if (this.debug) {
                cmd.log(`Retrieved request digest. Retrieving web identity...`);
            }
            return clientSvcCommons.getCurrentWebIdentity(args.options.webUrl, requestDigest);
        })
            .then((identityResp) => {
            webIdentityResp = identityResp;
            if (this.debug) {
                cmd.log(`Retrieved web identity.`);
            }
            if (this.verbose) {
                cmd.log(`Checking if the site is a no-script site...`);
            }
            return propertybag_base_1.SpoPropertyBagBaseCommand.isNoScriptSite(args.options.webUrl, requestDigest, webIdentityResp, clientSvcCommons);
        })
            .then((isNoScriptSite) => {
            if (isNoScriptSite) {
                if (this.verbose) {
                    cmd.log(`Site is a no-script site. Reindexing lists instead...`);
                }
                return this.reindexLists(args.options.webUrl, requestDigest, cmd, webIdentityResp, clientSvcCommons);
            }
            if (this.verbose) {
                cmd.log(`Site is not a no-script site. Reindexing site...`);
            }
            const requestOptions = {
                url: `${args.options.webUrl}/_api/web/allproperties`,
                headers: {
                    'accept': 'application/json;odata=nometadata'
                },
                json: true
            };
            return request_1.default.get(requestOptions);
        })
            .then((webProperties) => {
            let searchVersion = webProperties.vti_x005f_searchversion || 0;
            searchVersion++;
            return propertybag_base_1.SpoPropertyBagBaseCommand.setProperty('vti_searchversion', searchVersion.toString(), args.options.webUrl, requestDigest, webIdentityResp, cmd, this.debug);
        })
            .then(() => {
            if (this.verbose) {
                cmd.log(vorpal.chalk.green('DONE'));
            }
            cb();
        }, (err) => {
            if (this.reindexedLists) {
                if (this.verbose) {
                    cmd.log(vorpal.chalk.green('DONE'));
                }
                cb();
            }
            else {
                this.handleRejectedPromise(err, cmd, cb);
            }
        });
    }
    reindexLists(webUrl, requestDigest, cmd, webIdentityResp, clientSvcCommons) {
        return new Promise((resolve, reject) => {
            (() => {
                if (this.debug) {
                    cmd.log(`Retrieving information about lists...`);
                }
                const requestOptions = {
                    url: `${webUrl}/_api/web/lists?$select=NoCrawl,Title,RootFolder/Properties,RootFolder/ServerRelativeUrl&$expand=RootFolder/Properties`,
                    headers: {
                        'accept': 'application/json;odata=nometadata'
                    },
                    json: true
                };
                return request_1.default.get(requestOptions);
            })()
                .then((lists) => {
                const promises = lists.value.map(l => this.reindexList(l, webUrl, requestDigest, webIdentityResp, clientSvcCommons, cmd));
                return Promise.all(promises);
            })
                .then(() => {
                this.reindexedLists = true;
                reject(undefined);
            }, (err) => reject(err));
        });
    }
    reindexList(list, webUrl, requestDigest, webIdentityResp, clientSvcCommons, cmd) {
        return new Promise((resolve, reject) => {
            if (list.NoCrawl) {
                if (this.debug) {
                    cmd.log(`List ${list.Title} is excluded from crawling`);
                }
                resolve();
                return;
            }
            clientSvcCommons
                .getFolderIdentity(webIdentityResp.objectIdentity, webUrl, list.RootFolder.ServerRelativeUrl, requestDigest)
                .then((folderIdentityResp) => {
                let searchversion = list.RootFolder.Properties.vti_x005f_searchversion || 0;
                searchversion++;
                return propertybag_base_1.SpoPropertyBagBaseCommand.setProperty('vti_searchversion', searchversion.toString(), webUrl, requestDigest, folderIdentityResp, cmd, this.debug, list.RootFolder.ServerRelativeUrl);
            })
                .then(() => {
                resolve();
            }, (err) => reject(err));
        });
    }
    options() {
        const options = [
            {
                option: '-u, --webUrl <webUrl>',
                description: 'URL of the subsite to reindex'
            }
        ];
        const parentOptions = super.options();
        return options.concat(parentOptions);
    }
    validate() {
        return (args) => {
            if (!args.options.webUrl) {
                return 'Required parameter webUrl missing';
            }
            const isValidSharePointUrl = SpoCommand_1.default.isValidSharePointUrl(args.options.webUrl);
            if (isValidSharePointUrl !== true) {
                return isValidSharePointUrl;
            }
            return true;
        };
    }
    commandHelp(args, log) {
        const chalk = vorpal.chalk;
        log(vorpal.find(this.name).helpInformation());
        log(`  Remarks:

    If the subsite to be reindexed is a no-script site, the command will request
    reindexing all lists from the subsite that haven't been excluded from the
    search index.
        
  Examples:
  
    Request reindexing the subsite ${chalk.grey('https://contoso.sharepoint.com/subsite')}
      ${this.name} --webUrl https://contoso.sharepoint.com/subsite
      `);
    }
}
module.exports = new SpoWebReindexCommand();
//# sourceMappingURL=web-reindex.js.map