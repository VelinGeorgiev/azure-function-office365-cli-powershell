"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request-promise-native");
const Auth_1 = require("./Auth");
const packageJSON = require('../package.json');
class Request {
    constructor() {
        this.req = request.defaults({
            headers: {
                'user-agent': `NONISV|SharePointPnP|Office365CLI/${packageJSON.version}`
            },
            gzip: true
        });
    }
    set debug(debug) {
        request.debug = debug;
    }
    set cmd(cmd) {
        this._cmd = cmd;
    }
    post(options) {
        options.method = 'POST';
        return this.execute(options);
    }
    get(options) {
        options.method = 'GET';
        return this.execute(options);
    }
    patch(options) {
        options.method = 'PATCH';
        return this.execute(options);
    }
    put(options) {
        options.method = 'PUT';
        return this.execute(options);
    }
    delete(options) {
        options.method = 'DELETE';
        return this.execute(options);
    }
    head(options) {
        options.method = 'HEAD';
        return this.execute(options);
    }
    execute(options, resolve, reject) {
        if (!this._cmd) {
            return Promise.reject('Command reference not set on the request object');
        }
        return new Promise((_resolve, _reject) => {
            const resource = Auth_1.Auth.getResourceFromUrl(options.url.toString());
            (() => {
                if (options.headers && options.headers['x-anonymous']) {
                    return Promise.resolve('');
                }
                else {
                    return Auth_1.default.ensureAccessToken(resource, this._cmd, request.debug);
                }
            })()
                .then((accessToken) => {
                if (options.headers) {
                    if (options.headers['x-anonymous']) {
                        delete options.headers['x-anonymous'];
                    }
                    else {
                        options.headers.authorization = `Bearer ${accessToken}`;
                    }
                }
                return this.req(options);
            })
                .then((res) => {
                if (request.debug && res) {
                    this._cmd.log('REQUEST response body');
                    this._cmd.log(JSON.stringify(res));
                }
                if (resolve) {
                    resolve(res);
                }
                else {
                    _resolve(res);
                }
            }, (error) => {
                if (error && error.response &&
                    (error.response.statusCode === 429 ||
                        error.response.statusCode === 503)) {
                    let retryAfter = parseInt(error.response.headers['retry-after'] || '10');
                    if (isNaN(retryAfter)) {
                        retryAfter = 10;
                    }
                    if (request.debug) {
                        this._cmd.log(`Request throttled. Waiting ${retryAfter}sec before retrying...`);
                    }
                    setTimeout(() => {
                        this.execute(options, resolve || _resolve, reject || _reject);
                    }, retryAfter * 1000);
                }
                else {
                    if (reject) {
                        reject(error);
                    }
                    else {
                        _reject(error);
                    }
                }
            });
        });
    }
}
exports.default = new Request();
//# sourceMappingURL=request.js.map