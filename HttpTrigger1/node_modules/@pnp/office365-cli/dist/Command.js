"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const appInsights_1 = require("./appInsights");
const request_1 = require("./request");
const Auth_1 = require("./Auth");
const vorpal = require('./vorpal-init');
class CommandError {
    constructor(message, code) {
        this.message = message;
        this.code = code;
    }
}
exports.CommandError = CommandError;
class Command {
    constructor() {
        this._debug = false;
        this._verbose = false;
    }
    get debug() {
        return this._debug;
    }
    get verbose() {
        return this._verbose;
    }
    showDeprecationWarning(cmd, deprecated, recommended) {
        if (cmd.commandWrapper.command.indexOf(deprecated) === 0) {
            cmd.log(vorpal.chalk.yellow(`Command '${deprecated}' is deprecated. Please use '${recommended}' instead`));
        }
    }
    getUsedCommandName(cmd) {
        const commandName = this.getCommandName();
        if (cmd.commandWrapper.command.indexOf(commandName) === 0) {
            return commandName;
        }
        if (!this.alias()) {
            return '';
        }
        // since the command was called by something else than its name
        // it must have aliases
        const aliases = this.alias();
        for (let i = 0; i < aliases.length; i++) {
            if (cmd.commandWrapper.command.indexOf(aliases[i]) === 0) {
                return aliases[i];
            }
        }
        // shouldn't happen because the command is called either by its name or alias
        return '';
    }
    action() {
        const cmd = this;
        return function (args, cb) {
            Auth_1.default
                .restoreAuth()
                .then(() => {
                args = cmd.processArgs(args);
                cmd.initAction(args, this);
                if (!Auth_1.default.service.connected) {
                    cb(new CommandError('Log in to Office 365 first'));
                    return;
                }
                cmd.commandAction(this, args, cb);
            }, (error) => {
                cb(new CommandError(error));
            });
        };
    }
    getTelemetryProperties(args) {
        return {
            debug: this.debug.toString(),
            verbose: this.verbose.toString()
        };
    }
    alias() {
        return;
    }
    autocomplete() {
        return;
    }
    allowUnknownOptions() {
        return;
    }
    options() {
        return [
            {
                option: '--query [query]',
                description: 'JMESPath query string. See http://jmespath.org/ for more information and examples'
            },
            {
                option: '-o, --output [output]',
                description: 'Output type. json|text. Default text',
                autocomplete: ['json', 'text']
            },
            {
                option: '--pretty',
                description: 'Prettifies json output'
            },
            {
                option: '--verbose',
                description: 'Runs command with verbose logging'
            },
            {
                option: '--debug',
                description: 'Runs command with debug logging'
            }
        ];
    }
    help() {
        const cmd = this;
        return function (args, cbOrLog) {
            const ranFromHelpCommand = typeof vorpal._command !== 'undefined' &&
                typeof vorpal._command.command !== 'undefined' &&
                vorpal._command.command.indexOf('help ') === 0;
            const log = ranFromHelpCommand ? cbOrLog : this.log.bind(this);
            cmd.commandHelp(args, log);
            if (!ranFromHelpCommand) {
                cbOrLog();
            }
        };
    }
    validate() {
        return;
    }
    cancel() {
        return;
    }
    types() {
        return;
    }
    init(vorpal) {
        const cmd = vorpal
            .command(this.name, this.description, this.autocomplete())
            .action(this.action());
        const options = this.options();
        options.forEach((o) => {
            cmd.option(o.option, o.description, o.autocomplete);
        });
        const alias = this.alias();
        if (alias) {
            cmd.alias(alias);
        }
        const validate = this.validate();
        if (validate) {
            cmd.validate(validate);
        }
        const cancel = this.cancel();
        if (cancel) {
            cmd.cancel(cancel);
        }
        const allowUnknownOptions = this.allowUnknownOptions();
        if (allowUnknownOptions) {
            cmd.allowUnknownOptions();
        }
        cmd.help(this.help());
        const types = this.types();
        if (types) {
            cmd.types(types);
        }
    }
    getCommandName() {
        let commandName = this.name;
        let pos = commandName.indexOf('<');
        let pos1 = commandName.indexOf('[');
        if (pos > -1 || pos1 > -1) {
            if (pos1 > -1) {
                pos = pos1;
            }
            commandName = commandName.substr(0, pos).trim();
        }
        return commandName;
    }
    handleRejectedODataPromise(rawResponse, cmd, callback) {
        const res = JSON.parse(JSON.stringify(rawResponse));
        if (res.error) {
            try {
                const err = JSON.parse(res.error);
                callback(new CommandError(err['odata.error'].message.value));
            }
            catch (_a) {
                try {
                    const graphResponseError = res.error;
                    if (graphResponseError.error.code) {
                        callback(new CommandError(graphResponseError.error.code + " - " + graphResponseError.error.message));
                    }
                    else {
                        callback(new CommandError(graphResponseError.error.message));
                    }
                }
                catch (_b) {
                    callback(new CommandError(res.error));
                }
            }
        }
        else {
            if (rawResponse instanceof Error) {
                callback(new CommandError(rawResponse.message));
            }
            else {
                callback(new CommandError(rawResponse));
            }
        }
    }
    handleRejectedODataJsonPromise(response, cmd, callback) {
        if (response.error &&
            response.error['odata.error'] &&
            response.error['odata.error'].message) {
            callback(new CommandError(response.error['odata.error'].message.value));
        }
        else {
            if (response.error) {
                if (response.error.error &&
                    response.error.error.message) {
                    callback(new CommandError(response.error.error.message));
                }
                else {
                    if (response.error.message) {
                        callback(new CommandError(response.error.message));
                    }
                    else {
                        if (response.error.error_description) {
                            callback(new CommandError(response.error.error_description));
                        }
                        else {
                            try {
                                const error = JSON.parse(response.error);
                                if (error &&
                                    error.error &&
                                    error.error.message) {
                                    callback(new CommandError(error.error.message));
                                }
                                else {
                                    callback(new CommandError(response.error));
                                }
                            }
                            catch (_a) {
                                callback(new CommandError(response.error));
                            }
                        }
                    }
                }
            }
            else {
                if (response instanceof Error) {
                    callback(new CommandError(response.message));
                }
                else {
                    callback(new CommandError(response));
                }
            }
        }
    }
    handleError(rawResponse, cmd, callback) {
        if (rawResponse instanceof Error) {
            callback(new CommandError(rawResponse.message));
        }
        else {
            callback(new CommandError(rawResponse));
        }
    }
    handleRejectedPromise(rawResponse, cmd, callback) {
        this.handleError(rawResponse, cmd, callback);
    }
    initAction(args, cmd) {
        this._debug = args.options.debug || process.env.OFFICE365CLI_DEBUG === '1';
        this._verbose = this._debug || args.options.verbose || process.env.OFFICE365CLI_VERBOSE === '1';
        request_1.default.debug = this._debug;
        request_1.default.cmd = cmd;
        appInsights_1.default.trackEvent({
            name: this.getUsedCommandName(cmd),
            properties: this.getTelemetryProperties(args)
        });
        appInsights_1.default.flush();
    }
    processArgs(args) {
        if (!this.allowUnknownOptions()) {
            return args;
        }
        const commandData = vorpal.util.parseCommand(process.argv.slice(2).join(' '), vorpal.commands);
        const cmd = commandData.match;
        // required for tests not to fail.
        // Can't happen on runtime because we are already inside a command
        if (!cmd) {
            return args;
        }
        if (!cmd._types) {
            cmd._types = {};
        }
        if (!cmd._types.string) {
            cmd._types.string = [];
        }
        process.argv.slice(2).forEach(a => {
            if (!a.startsWith('--')) {
                return;
            }
            if (!cmd.options.find((o) => o.long === a)) {
                cmd._types.string.push(a.substr(2));
            }
        });
        args = vorpal.util.buildCommandArgs(commandData.matchArgs, cmd, undefined, vorpal.isCommandArgKeyPairNormalized);
        return args;
    }
    getUnknownOptions(options) {
        const unknownOptions = JSON.parse(JSON.stringify(options));
        const knownOptions = this.options();
        const optionRegex = /--([^\s]+)/;
        knownOptions.forEach(o => {
            const optionName = optionRegex.exec(o.option)[1];
            delete unknownOptions[optionName];
        });
        return unknownOptions;
    }
    trackUnknownOptions(telemetryProps, options) {
        const unknownOptions = this.getUnknownOptions(options);
        const unknownOptionsNames = Object.getOwnPropertyNames(unknownOptions);
        unknownOptionsNames.forEach(o => {
            telemetryProps[o] = true;
        });
    }
    addUnknownOptionsToPayload(payload, options) {
        const unknownOptions = this.getUnknownOptions(options);
        const unknownOptionsNames = Object.getOwnPropertyNames(unknownOptions);
        unknownOptionsNames.forEach(o => {
            payload[o] = unknownOptions[o];
        });
    }
}
exports.default = Command;
//# sourceMappingURL=Command.js.map